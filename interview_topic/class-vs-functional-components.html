<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class vs Functional Components</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .section:hover {
            transform: translateY(-5px);
        }
        
        .section h2 {
            color: #5a67d8;
            margin-bottom: 15px;
            border-bottom: 3px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .component-example {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #5a67d8;
        }
        
        .component-example h3 {
            color: #2d3748;
            margin-bottom: 15px;
        }
        
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .lifecycle-diagram {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .lifecycle-phase {
            background: rgba(255,255,255,0.1);
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ffd700;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background: #5a67d8;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .comparison-table tr:nth-child(even) {
            background: #f7fafc;
        }
        
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .pros, .cons {
            padding: 20px;
            border-radius: 10px;
        }
        
        .pros {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }
        
        .cons {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
        }
        
        .trend-indicator {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #2d3748;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .migration-steps {
            background: #edf2f7;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .migration-steps ol {
            margin-left: 20px;
        }
        
        .migration-steps li {
            margin: 10px 0;
            padding: 8px;
            background: white;
            border-radius: 5px;
            border-left: 3px solid #5a67d8;
        }
        
        .highlight {
            background: #fef5e7;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #f6ad55;
            margin: 15px 0;
        }
        
        @media (max-width: 768px) {
            .comparison-grid, .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Class vs Functional Components</h1>
            <p>Complete Guide with Examples, Lifecycle Methods & Migration Strategies</p>
        </div>

        <div class="section">
            <h2>üìä Quick Comparison Overview</h2>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>Class Components</th>
                        <th>Functional Components</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Syntax</strong></td>
                        <td>ES6 Class syntax</td>
                        <td>Simple JavaScript function</td>
                    </tr>
                    <tr>
                        <td><strong>State Management</strong></td>
                        <td>this.state & this.setState()</td>
                        <td>useState() Hook</td>
                    </tr>
                    <tr>
                        <td><strong>Lifecycle Methods</strong></td>
                        <td>Built-in methods (componentDidMount, etc.)</td>
                        <td>useEffect() Hook</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>Slightly heavier</td>
                        <td>Lighter, better optimization</td>
                    </tr>
                    <tr>
                        <td><strong>Code Reusability</strong></td>
                        <td>Higher-Order Components (HOCs)</td>
                        <td>Custom Hooks</td>
                    </tr>
                    <tr>
                        <td><strong>Bundle Size</strong></td>
                        <td>Larger</td>
                        <td>Smaller</td>
                    </tr>
                    <tr>
                        <td><strong>Learning Curve</strong></td>
                        <td>Steeper (OOP concepts)</td>
                        <td>Easier for beginners</td>
                    </tr>
                    <tr>
                        <td><strong>Current Trend</strong></td>
                        <td>Legacy/Maintenance</td>
                        <td>Modern React Standard</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>üíª Code Examples Comparison</h2>
            <div class="comparison-grid">
                <div class="component-example">
                    <h3>üèõÔ∏è Class Component</h3>
                    <pre><code>import React, { Component } from 'react';

class UserProfile extends Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      loading: true,
      count: 0
    };
  }

  componentDidMount() {
    this.fetchUser();
  }

  componentDidUpdate(prevProps) {
    if (prevProps.userId !== this.props.userId) {
      this.fetchUser();
    }
  }

  componentWillUnmount() {
    // Cleanup subscriptions
    clearInterval(this.interval);
  }

  fetchUser = async () => {
    this.setState({ loading: true });
    try {
      const response = await fetch(`/api/users/${this.props.userId}`);
      const user = await response.json();
      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ loading: false });
    }
  }

  incrementCount = () => {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  }

  render() {
    const { user, loading, count } = this.state;
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    
    return (
      &lt;div&gt;
        &lt;h2&gt;{user?.name}&lt;/h2&gt;
        &lt;p&gt;Count: {count}&lt;/p&gt;
        &lt;button onClick={this.incrementCount}&gt;
          Increment
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
                </div>

                <div class="component-example">
                    <h3>‚ö° Functional Component</h3>
                    <pre><code>import React, { useState, useEffect } from 'react';

const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [count, setCount] = useState(0);

  const fetchUser = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      setUser(userData);
    } catch (error) {
      console.error('Error fetching user:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchUser();
  }, [userId]); // Dependency array

  useEffect(() => {
    // Cleanup function
    return () => {
      // Cleanup subscriptions
      clearInterval(interval);
    };
  }, []);

  const incrementCount = () => {
    setCount(prevCount => prevCount + 1);
  };

  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h2&gt;{user?.name}&lt;/h2&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={incrementCount}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default UserProfile;</code></pre>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üîÑ Lifecycle Methods Mapping</h2>
            <div class="lifecycle-diagram">
                <h3>Class Component Lifecycle ‚Üí Functional Component Hooks</h3>
                
                <div class="lifecycle-phase">
                    <h4>üöÄ Mounting Phase</h4>
                    <p><strong>constructor()</strong> ‚Üí <code>useState()</code> for initial state</p>
                    <p><strong>componentDidMount()</strong> ‚Üí <code>useEffect(() => {}, [])</code></p>
                </div>
                
                <div class="lifecycle-phase">
                    <h4>üîÑ Updating Phase</h4>
                    <p><strong>componentDidUpdate()</strong> ‚Üí <code>useEffect(() => {}, [dependencies])</code></p>
                    <p><strong>shouldComponentUpdate()</strong> ‚Üí <code>React.memo()</code> or <code>useMemo()</code></p>
                </div>
                
                <div class="lifecycle-phase">
                    <h4>üíÄ Unmounting Phase</h4>
                    <p><strong>componentWillUnmount()</strong> ‚Üí <code>useEffect(() => { return () => cleanup }, [])</code></p>
                </div>
                
                <div class="lifecycle-phase">
                    <h4>‚ùå Error Handling</h4>
                    <p><strong>componentDidCatch()</strong> ‚Üí No direct hook equivalent (use Error Boundaries)</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>üìà When to Use Which?</h2>
            
            <div class="highlight">
                <h3>üèõÔ∏è Use Class Components When:</h3>
                <ul>
                    <li>Working with legacy codebases that heavily use classes</li>
                    <li>Need Error Boundaries (componentDidCatch)</li>
                    <li>Team is more comfortable with OOP patterns</li>
                    <li>Complex lifecycle logic that's hard to refactor</li>
                </ul>
            </div>
            
            <div class="highlight">
                <h3>‚ö° Use Functional Components When:</h3>
                <ul>
                    <li>Starting new projects (React 16.8+)</li>
                    <li>Need better performance and smaller bundle size</li>
                    <li>Want cleaner, more readable code</li>
                    <li>Building reusable logic with custom hooks</li>
                    <li>Following modern React patterns</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>üìä Pros & Cons Analysis</h2>
            <div class="pros-cons">
                <div class="pros">
                    <h3>‚úÖ Class Components Pros</h3>
                    <ul>
                        <li>Familiar OOP syntax</li>
                        <li>Built-in lifecycle methods</li>
                        <li>Error boundary support</li>
                        <li>Mature ecosystem</li>
                        <li>this.state batching</li>
                    </ul>
                </div>
                <div class="cons">
                    <h3>‚ùå Class Components Cons</h3>
                    <ul>
                        <li>More verbose syntax</li>
                        <li>this binding confusion</li>
                        <li>Larger bundle size</li>
                        <li>Hard to optimize</li>
                        <li>Less reusable logic</li>
                    </ul>
                </div>
            </div>
            
            <div class="pros-cons">
                <div class="pros">
                    <h3>‚úÖ Functional Components Pros</h3>
                    <ul>
                        <li>Cleaner, simpler syntax</li>
                        <li>Better performance</li>
                        <li>Easier testing</li>
                        <li>Custom hooks reusability</li>
                        <li>Future-proof</li>
                    </ul>
                </div>
                <div class="cons">
                    <h3>‚ùå Functional Components Cons</h3>
                    <ul>
                        <li>Learning curve for hooks</li>
                        <li>No error boundaries</li>
                        <li>Requires React 16.8+</li>
                        <li>useEffect complexity</li>
                        <li>Stale closure issues</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="trend-indicator">
            <h3>üìà Current Trend: Functional Components are the Future!</h3>
            <p>React team recommends functional components for all new projects. Hooks provide better performance, cleaner code, and improved developer experience.</p>
        </div>

        <div class="section">
            <h2>üîÑ Migration Strategy: Class to Functional</h2>
            <div class="migration-steps">
                <h3>Step-by-Step Migration Process:</h3>
                <ol>
                    <li><strong>Identify Dependencies:</strong> List all props, state, and lifecycle methods used</li>
                    <li><strong>Convert State:</strong> Replace <code>this.state</code> with <code>useState</code> hooks</li>
                    <li><strong>Replace Lifecycle Methods:</strong> Convert to appropriate <code>useEffect</code> hooks</li>
                    <li><strong>Remove Class Syntax:</strong> Convert class to function, remove render method</li>
                    <li><strong>Update Event Handlers:</strong> Remove arrow functions or bind calls</li>
                    <li><strong>Test Thoroughly:</strong> Ensure all functionality works as expected</li>
                    <li><strong>Optimize:</strong> Look for opportunities to use custom hooks</li>
                </ol>
            </div>
        </div>

        <div class="section">
            <h2>üéØ Real-World Scenarios</h2>
            
            <div class="highlight">
                <h3>Scenario 1: E-commerce Product List</h3>
                <p><strong>Class Component Approach:</strong> Multiple lifecycle methods, complex state management</p>
                <p><strong>Functional Component Approach:</strong> Clean useEffect for data fetching, custom hooks for cart logic</p>
                <p><strong>Winner:</strong> Functional - Better performance for list rendering, easier state updates</p>
            </div>
            
            <div class="highlight">
                <h3>Scenario 2: Form with Validation</h3>
                <p><strong>Class Component Approach:</strong> setState for each field, validation in lifecycle methods</p>
                <p><strong>Functional Component Approach:</strong> useReducer for complex form state, custom validation hooks</p>
                <p><strong>Winner:</strong> Functional - Custom hooks make validation reusable across forms</p>
            </div>
            
            <div class="highlight">
                <h3>Scenario 3: Error Boundary</h3>
                <p><strong>Class Component Approach:</strong> componentDidCatch, getDerivedStateFromError</p>
                <p><strong>Functional Component Approach:</strong> No direct equivalent</p>
                <p><strong>Winner:</strong> Class - Only way to implement error boundaries currently</p>
            </div>
        </div>

        <div class="section">
            <h2>üöÄ Advanced Hook Patterns</h2>
            <div class="component-example">
                <h3>Custom Hook Example</h3>
                <pre><code>// Custom hook for API calls
const useApi = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return { data, loading, error };
};

// Usage in component
const UserList = () => {
  const { data: users, loading, error } = useApi('/api/users');
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>üéì Key Takeaways</h2>
            <div class="highlight">
                <ul>
                    <li><strong>Modern Standard:</strong> Functional components with hooks are the current React standard</li>
                    <li><strong>Performance:</strong> Functional components generally offer better performance and smaller bundles</li>
                    <li><strong>Migration:</strong> Gradual migration is recommended for existing class-based codebases</li>
                    <li><strong>Learning:</strong> New developers should focus on functional components and hooks</li>
                    <li><strong>Error Boundaries:</strong> Still require class components (for now)</li>
                    <li><strong>Custom Hooks:</strong> Provide superior logic reusability compared to HOCs</li>
                </ul>
            </div>
        </div>
    </div>
</body>
</html>